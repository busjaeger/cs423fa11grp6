If the shared buffer needs to be accessed concurrently, then this becomes an instance of the producer/
consumer problem. Two requirements need to be met to ensure proper synchronization:

1. mutual exclusion: only one thread should access the shared buffer at any given time
2. sequencing: access must be properly sequenced to ensure the producer only adds entries if space is available
   and the consumer only removes entries if present

If it is possible for the montoring user process and the profiling kernel thread to share synchronization
primitives through the shared buffer and call the operations on those primitives from their respective
spaces, then access could be synchronized with the following shared data structure placed at the beginning
of the memory buffer:

unsigned long *write_pos
unsigned long *read_pos
long canceled
semaphore full
semaphore empty
mutex lock

kernel and user share constants SIZE (size of buffer) and OFFSET (start of profiling data within buffer)

## kernel init
buffer_first = allocate buffer SIZE
buffer_last = buffer_first + SIZE
write_pos = buffer_first + OFFSET
read_pos = buffer_first + OFFSET
canceled = false
full = new semaphore initilized to '0'
empty = new semaphore initialized to 'SIZE/4'
lock = new mutex
start profile thread

## kernel profile thread
while(!canceled) {
  //read process data
  down(empty);
  lock(lock);
  write_pos++=jiffies;
  write_pos++=min;
  write_pos++=maj;
  write_pos=time;
  if (write_pos == buffer_last)
    write_pos = buffer_first + OFFSET;
  else
    write_pos++;
  unlock(lock);
  up(full);
}

## monitor init:
buffer_first = map memory area of SIZE
buffer_last = buffer_first + SIZE;

## monitor thread:
log_buf;
done;
while (true) {
  down(full);
  lock(lock);
  log_buf[i++] = *read_pos++;
  log_buf[i++] = *read_pos++;
  log_buf[i++] = *read_pos++;
  log_buf[i++] = *read_pos;
  if (read_pos == buffer_last)
    read_pos = buffer_first + OFFSET;
  else
    read_pos++;
  done = canceled;
  unlock(lock);
  up(empty);

  if (log_buf.size > threshold)
    dump(log_buf)

  if (done && read_pos == write_pos) {
    dump(log_buf)
    break;
  }
}

This relies on the assumption that semaphores and mutexes can be shared by user and kernel mode. The semaphore
functions called from user space would likely need to enter kernel space, i.e. it would likely have a different
implementation than the kernel space version, but should act on the same memory region. The approach also
requires frequent locking even though the buffer is quite large. Another issue is that the monitor thread blocks
if the full buffer has been written, but the monitor has not read it. No data is lost, but the next profiling
interval will be much larger, therefore precision is lost.
